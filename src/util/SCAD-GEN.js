import { noteIndexToPinIndices, noteName } from "./noteKey";

export const scadGen = (notes) => {
    const generatePins = (pins, side) => {
		//if pins are spaced along the circumference of the track more closely than this,
		//the gear will not engage properly and the tone arm will jump.
		const minPinSpacing = 5;
		
        //get the total number opf beats, every array index should be the same length
        const totalBeats = pins[0].length;
        //get the spacing needed to evenly space all notes around the circle
        const space = 360 / totalBeats;
        let output = ``;
		let noteToCount = [];
		let pinToLastAngle = [];
		
        for (let beatIndex = 0; beatIndex < totalBeats; beatIndex++) {
			for (let noteIndex = 0; noteIndex < 16; noteIndex++) {
                if (pins[noteIndex][beatIndex]) {
					if (noteToCount[noteIndex] === undefined) {
						noteToCount[noteIndex] = 0;
					}
					const pinIndices = noteIndexToPinIndices[noteIndex];
					const pinIndex = pinIndices[noteToCount[noteIndex] % pinIndices.length];
					const pinAngle = space * beatIndex;
					const pinRadius = 28.55 + pinIndex * 27.8 / 20;
					const pinCircumference = 2 * Math.PI * pinRadius;
					const circumferenceToLastPin = (pinAngle - (pinToLastAngle[pinIndex] || -360)) / 360 * pinCircumference;
					const badSpacing = circumferenceToLastPin < minPinSpacing;
					if (badSpacing) {
						const noteIndex = noteIndexToPinIndices.findIndex(pins => pins.includes(pinIndex));
						const friendlyNoteName = noteName[noteIndex];
						output += `
				echo("Pin on side ${side} beat ${beatIndex} note ${friendlyNoteName} is too close to the last pin. Distance is ${circumferenceToLastPin} but we want at least ${minPinSpacing}");`;
					}

					noteToCount[noteIndex]++;
					if (!badSpacing) {
						pinToLastAngle[pinIndex] = pinAngle;
					}
                    output += `
				pin(${pinIndex},${pinAngle},${side},${badSpacing});`;					
                }
            }
        }
        return output;
    };

    return {
        text: `
/* This file has been generated by Chris's Fisher Price Record Maker
 * This file was taken from  Fred's Fisher Price Record Creator. Thanks for all your hard work Fred!
 * http://www.instructables.com/id/3D-printing-records-for-a-Fisher-Price-toy-record-/
 *
 * Press F6 to view your model in OpenSCAD
 * Then you cn export as STL for printing
 */

// Configuration

$fn = 360;
holeClearance = 0.4;

hStock = 4.6;
rStock = 121.1 / 2;
rCenterHole = (6.55 + holeClearance) / 2;
oDrive = 21.8;
rDrive = (3.1 + holeClearance) / 2;
hInset = 1.6; // I measure ~1.4, but erring high to ensure we ride on the flats, not the inset.
rInset = 50.9 / 2;
hGroove = 1.6; // I measure ~1.3, but we want to err high so the tone arm doesn't jump as the gears rotate.
trackSpacing = (55.9 - 28.15) / 10;  // It's not exactly linear, but close enough if the tone arm offset is small.
wGroove = .6; // I measure about .8, but elephant's foot on the bottom can expaind it so much the tone arm won't fit.
wTrack = trackSpacing - wGroove;
pinWidth = .8;
overlap = 0.2;

hasSecondSide = 1;

// Some very useful code by HarlanDMii
// http://www.thingiverse.com/thing:16193
// Disabled as some people had problems with it
// Uncomment to create title 
// If you have trouble, download https://github.com/rohieb/Write.scad and copy all the files to the same directory as this SCAD file
// include <write.scad>

// Tone arm geometry, so that chords are staggered appropriately to not sound arpeggiated.
toneArmPivotPosition = [96, 71];
// Tweak this to account for the slop in the tone arm pivot, such that chords sound good.
toneArmLengthFudge = 2;
toneArmLength = 113.5 + toneArmLengthFudge;
toneArmTrackSpacing = 27.8 / 20;
toneArmNumTracks = 22;
// The above is measured, and then this is fudged until the pins line up with the grooves.
toneArmAngle = 237.5;

// Create disc
module createDisc() {
	union() {

		createBlank();

		// Add the notes for the song. This part is dynamically generated.
		// Autogenerated pins for music tracks
		${generatePins(notes[0], 0)}
	

		title("${notes[0][16]}",0);

		// Autogenerated pins for music tracks
		${generatePins(notes[1], 1)}


		title("${notes[1][16]}",1);


	}
}

// Create the blank, ready for dynamically added pins
module createBlank() {

	difference() {
	
		rotate_extrude(convexity=12) {
			difference() {
				// stock
				square([rStock, hStock]);

				// top cutout
				translate([0, hStock - hInset]) square([rInset, hInset + overlap]);

				// Bottom cutout lets the disc sit flatter, but some printers my struggle with the overhang
				translate([0, -overlap]) square([rInset, hInset + overlap]);

				// Centre hole		
				translate([0, 0]) square([rCenterHole, hStock]);

				// Tracks - each one for two notes
				for (s = [0, hasSecondSide])
				for (t = [0 : 10])
				track(28.15 + t * trackSpacing, s);
			}
		}	

		// Drive holes
		translate(v = [0,oDrive,0]) { cylinder(h=hStock, r=rDrive); }
		translate(v = [0,-oDrive,0]) { cylinder(h=hStock, r=rDrive); }
		translate(v = [oDrive,0,0]) { cylinder(h=hStock, r=rDrive); }
		translate(v = [-oDrive,0,0]) { cylinder(h=hStock, r=rDrive); }		
	}
}

// Negative for a double track (2d, to be rotate_extruded)
module track(inner, onSecondSide) {
	if (onSecondSide > 0) {
		translate(v = [inner,-overlap]) {
			square(size=[wTrack, hGroove+overlap]);
		}
	}
	else {
		translate(v = [inner,hStock-hGroove]) {
			square(size=[wTrack, hGroove+overlap]);
		}
	}
}

// Create a pin at a certain angle
module pin(trackIndex, angle, onSecondSide, badSpacing)
{
	translate(onSecondSide * [0, 0, hStock / 2])
	rotate(onSecondSide * [180, 0, 0])
	translate(onSecondSide * [0, 0, -hStock / 2])	
	rotate(angle)
	translate(toneArmPivotPosition)
	rotate(toneArmAngle)
	translate([toneArmLength - pinWidth, (trackIndex - toneArmNumTracks / 2) * toneArmTrackSpacing, hStock - hGroove - overlap])
	color(badSpacing ? "red" : "green")
	cube(size = [pinWidth, toneArmTrackSpacing, hGroove * (badSpacing ? .1 : 1) + overlap]);
}

// Add text
module title(text, onSecondSide)
{
// Disabled as some people had trouble with it
// Uncomment to create title 
	//if (onSecondSide>0)
	//	writecylinder(text, [0,0,-hInset], radius=20, height=hStock-hInset, h=3, t=hInset, face="bottom");
	//else
		//writecylinder(text, [0,0,0], radius=20, height=hStock-hInset, h=3, t=hInset, face="top");
}

// Do the work
createDisc();
`,
        title: `${notes[0][16]} & ${notes[1][16]}`,
    };
};
